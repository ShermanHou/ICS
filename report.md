# DataLab report

## Problem1 bitXor
从可用出发，可用的是~和&，

直接使用&可以得到(有0的pairs)->0,也即(全1的pairs)->1

与~结合，还可以得到(有1的pairs)->0,也即(全0的pairs)->1

我们需要的是(全0的或全1的)->0,也即(不全为0且不全为1的)->1
故为~全1&~全0

```c
int bitXor(int x, int y) {
  int a = x & y;//全为1的位
  int b = ~x & ~y;//全为0的位
  int c = ~a & ~b;//不全为1
  return c;
}
```
## Problem2 thirdBits
题目即从LSB开始记为第1位，1，4，7...这样每三位赋1，返回32位的结果。
由于题目限制给定常数最长可以是8bits,我们需要通过对"位段"移位来拓展。

初值赋为ox49,移位使得恰好错位拓展2倍，<<9，获得18长度的，

再<<18，获得36长度的,return int截取32位即可。
```c
int thirdBits(void) {
  int x = 0x49;
  x = (x<<9) + x;
  x = (x<<18) + x;
  return x;
}
```
## Problem3 fitsShort
题目即给一个32位的数，判断16位是否足够表示它。

若可以，最左边17位需要全为1或者0，但是，

这个想法有点绕，回归本质：即最左边16位由前一位拓展，不妨借助算数移位的特性，构造补位数，抑或原来的，判断是否一样。
```c
int fitsShort(int x) {
  int y = (x<<16)>>16;
  int z = y^x;
  return !z;
}
```
## Problem4 isTmax
判断x是否是0x7FFFFFFF这个数，一开始的思路是直接刨析这个数表示的本身，第一位是0，剩下的是1,不能用移位，不好办;

想一下它的特性，特殊点在于"最大"，只有它再大点会出"问题":加了1，变为负数?负数的判断本质还是要用移位才比较好，实际上我们不应该考虑负数不负数的，要考虑的是位本身的特点——加1后的再左移1位成了0!
这里的左移1位是容易实现的，只需要加上自己就行了。

这似乎是其他数都做不到的，真的是这样吗？很不幸，-1也是如此，因此要排除-1。
| x | 0x7FFFFFFF | 0xFFFFFFFF |
| :-----:| ----: | ----: |
| x+1 | 0x00 80000000 | 0x01 00000000 |
| (x+1)+(x+1) | 0x08 00000000 | 0x10 00000000 |

其实区别很简单...-1加1是0，而0x7FFFFFFF+1不是。不能是0，即取非后要为0，把所需为0的部分或！(x+1)即可。
```c
int isTmax(int x) {
  int y = x + 1;
  int z = y + y;
  return !(z|(!y));
}
```
## Problem5 fitsBits
输入n和x,判断x是否能只用n位表示。若能，同第3题，则第n位前的都由第n位拓展，左移32-n位，再右移这么多位。判断与原数是否相等即可。
## Problem6 upperBits
应该还是需要利用算数移位的特性，构造100...0，右移n-1位即可。但n=0时会是右移-1位，经试验，会变为-1，在答案加!n即可实现分类讨论。
```c
int upperBits(int n) {
    return ((1<<(31))>>(n+~0))+!n;
}
```
## Problem7 anyOddBit
构造掩码，设为偶数位全为1，奇数位全为0的；与原数作&操作，偶数位有1的返回非0数，无1的返回0，取两次!即满足题设。
```c
int anyOddBit(int x) {
    int mask = 0xAA;
    mask = mask+(mask<<8);
    mask = mask+(mask<<16);
    return !!((x&mask));
}
```
## Problem8 byteSwap
直观上，所需作的操作是把位段作交换，需要用一定的掩码构造一下加一下；但是，稍微仔细想一下就不难知道，这样的操作在位变化角度看来效率很低，有些位实际上并没有变化。

我们需要关注的是两段在相同相对位置处相异的位。n和m<<3位乘8倍后，x往右分别推这么多位，求^,保留不同的位为1，再用0xFF过滤一下即得**描述差异的段**。再移动到两个相应位置，用^作用于x，把**有差异、需要改变的位**0，1置反即可。
```c
int byteSwap(int x, int n, int m) {
  int y = 0;
  n = n<<3;
  m = m<<3;
  y = 0xff & ((x>>n) ^ (x>>m));
  x = x ^ (y<<n); 
  x = x ^ (y<<m);
  return x;
}
```
## Problem9 absVal
需要先对正负数作分类讨论，先取符号位，右移后实际上得到：负数为-1，正数为0；与上一个题中最后^符号的利用类似，a^一个数会使**这个数为1的位上**a的位置置反；极端情况即为，^0无变化，^(-1)等价于取~,潜在实现了是否~的分类操作。
$$A+(-A)=0$$
$$A+(\~A)=-1$$
$$-A=\~A+1$$
因为取相反数，+-1，取~均为互逆运算，$\~A+1=\~(A-1)$
直接在-1和^处利用上面得到的-1(和0)操作即可。
```c
int absVal(int x) {
  int mark = x>>31;
  return (x+mark)^mark;
}
```
## Problem10 divpwr2
